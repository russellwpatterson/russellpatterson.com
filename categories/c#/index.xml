<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C# on Russell Writes Code</title><link>/categories/c#/</link><description>Recent content in C# on Russell Writes Code</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 01 Apr 2018 23:00:33 +0000</lastBuildDate><atom:link href="/categories/c#/index.xml" rel="self" type="application/rss+xml"/><item><title>New in C# 7.0: Part 4 - Expression-Bodied Members</title><link>/2018/04/new-in-c-7-0-part-4-expression-bodied-members/</link><pubDate>Sun, 01 Apr 2018 23:00:33 +0000</pubDate><guid>/2018/04/new-in-c-7-0-part-4-expression-bodied-members/</guid><description>This week, we&amp;rsquo;re discussing Expression-Bodied Members in C# 7.0. Now, this was an existing feature in C# 6.0, but it was limited to only methods, like so:
public void DoAThingCS6() =&amp;gt; Console.WriteLine(&amp;quot;This is a test&amp;quot;); With the new additions in C# 7.0, we can now do Constructors, Deconstructors, and Properties. A Constructor definition looks like this:
public SomeClass() =&amp;gt; DoAThing(); Similarly, a Deconstructor looks like this:
~SomeClass() =&amp;gt; DoAThing(); Finally, although auto-properties are shorter, you can write properties with specific implementations with this new shorthand:</description></item><item><title>New in C# 7.0: Part 3 – Ref Returns</title><link>/2018/03/new-in-c-7-0-part-3-ref-returns/</link><pubDate>Sun, 25 Mar 2018 23:00:10 +0000</pubDate><guid>/2018/03/new-in-c-7-0-part-3-ref-returns/</guid><description>Picking up where I left off last week, there&amp;rsquo;s another interesting new feature called &amp;ldquo;Ref Returns&amp;rdquo;. Similar to Ref Locals, this allows you to return a reference from a method, and then optionally use it as a Ref Local in the calling code.
Let&amp;rsquo;s look at the following method definition:
private static string[] strings = { &amp;quot;this&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;test&amp;quot; }; public static ref string GetSomeString(int number) { if (number &amp;lt; 0 || number &amp;gt;= strings.</description></item><item><title>New in C# 7.0: Part 2 – Ref Locals</title><link>/2018/03/new-in-c-7-0-part-2-ref-locals/</link><pubDate>Sun, 18 Mar 2018 23:22:39 +0000</pubDate><guid>/2018/03/new-in-c-7-0-part-2-ref-locals/</guid><description>After about a year, I&amp;rsquo;m finally trying to start writing some more blog posts, so I&amp;rsquo;ll pick up right where I left off. Today, I&amp;rsquo;m going to give a brief overview of Ref Locals.
Ref Locals allow you to create an alias for a variable so that you are not creating another copy of the data or reference (in the case of an object), in memory. In previous versions of C#, if you wanted to refer to a local variable with a different name, you&amp;rsquo;d have to do this:</description></item><item><title>New in C# 7.0: Part 1 - Out Variables</title><link>/2017/02/new-in-c-7-0-part-1-out-variables/</link><pubDate>Sat, 11 Feb 2017 13:00:09 +0000</pubDate><guid>/2017/02/new-in-c-7-0-part-1-out-variables/</guid><description>This is the first post in a series on the new features available in Visual Studio 2017 and C# 7.0. Today, I&amp;rsquo;m going to be talking about Out Variables.
One of the great new features is probably something you will use frequently, which is defining an out variable, and using that variable in the same statement. Currently, to use an out variable, one must do something like this:
DateTime dt; if (DateTime.</description></item></channel></rss>